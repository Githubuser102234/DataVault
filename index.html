<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">Secure Data Vault</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for the textarea and card content for aesthetics */
        textarea::-webkit-scrollbar, .content-container::-webkit-scrollbar, pre::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-thumb, .content-container::-webkit-scrollbar-thumb, pre::-webkit-scrollbar-thumb {
            background-color: #a5b4fc; /* Indigo-300 */
            border-radius: 4px;
        }
        textarea::-webkit-scrollbar-track, .content-container::-webkit-scrollbar-track, pre::-webkit-scrollbar-track {
            background-color: #f3f4f6; /* Gray-100 */
        }
        /* Ensure the media elements fill the container */
        #modal-media-container img, #modal-media-container video, #modal-media-container audio {
            max-width: 100%;
            height: auto;
            max-height: 35vh; /* Keep it constrained */
        }
        /* Style for the RAW view mode */
        body.raw-mode {
            background-color: #000;
            color: #ccc;
            padding: 1rem;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Responsive Modal Fix: Ensure main content scrolls, not the whole modal */
        #content-modal > div {
            /* max-h-[90vh] applied in HTML */
            display: flex;
            flex-direction: column;
        }
        #content-modal .modal-content-area {
            flex-grow: 1;
            overflow-y: auto;
            min-height: 0;
            max-height: 70vh; /* Set a max height for the content, allowing the buttons to show */
        }
        
        /* Specific styling for folder cards */
        .folder-card {
            border-left: 5px solid #3b82f6; /* Blue-500 */
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans min-h-screen">
    <!-- Main application container. Hidden in raw mode. -->
    <div id="app" class="max-w-4xl mx-auto p-4 sm:p-8">
        <!-- Header -->
        <div id="main-header" class="p-4 bg-white border-b border-gray-200 shadow-md rounded-t-xl">
            <h1 class="text-3xl font-extrabold text-gray-800 mb-1">
                <span class="text-indigo-600">Secure</span> Data Vault
            </h1>
            <p id="auth-status" class="text-sm text-gray-500">
                Awaiting authentication...
            </p>
        </div>

        <!-- Authentication Container -->
        <div id="auth-container" class="bg-white p-6 shadow-lg rounded-b-xl mb-6 hidden">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">Sign In / Sign Up</h2>
            <div id="auth-message" class="mb-3 p-3 rounded-lg text-sm hidden"></div>
            
            <form id="email-form" class="space-y-4">
                <input type="email" id="auth-email" placeholder="Email" required
                       class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                <input type="password" id="auth-password" placeholder="Password" required
                       class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                
                <div class="flex flex-col space-y-2">
                    <button type="submit" id="signin-btn" 
                            class="w-full py-3 rounded-lg font-bold text-white bg-indigo-600 hover:bg-indigo-700 transition-colors">
                        Sign In
                    </button>
                    <button type="button" id="signup-btn" 
                            class="w-full py-3 rounded-lg font-bold text-indigo-600 border border-indigo-600 hover:bg-indigo-50 transition-colors">
                        Create Account
                    </button>
                </div>
            </form>

            <div class="my-4 flex items-center">
                <hr class="flex-grow border-gray-300">
                <span class="mx-4 text-gray-500 text-sm">OR</span>
                <hr class="flex-grow border-gray-300">
            </div>

            <button type="button" id="google-signin-btn" 
                    class="w-full py-3 rounded-lg font-bold text-gray-700 border border-gray-300 bg-white hover:bg-gray-100 transition-colors flex items-center justify-center space-x-2">
                <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22.56 12.25c0-.62-.05-1.22-.16-1.81H12v3.42h5.71a4.25 4.25 0 01-1.84 2.79v2.24h2.89c1.69-1.55 2.66-3.83 2.66-6.64z" fill="#4285F4"/><path d="M12 22c3.08 0 5.67-1.03 7.56-2.8l-2.89-2.24c-.79.53-1.8.84-3.67.84-2.83 0-5.24-1.91-6.1-4.49H3.06v2.33C4.81 20.37 8.1 22 12 22z" fill="#34A853"/><path d="M5.9 14.73c-.22-.62-.35-1.3-.35-2.01s.13-1.39.35-2.01V8.39H3.06a9.55 9.55 0 000 7.22l2.84-1.68z" fill="#FBBC05"/><path d="M12 5.51c1.67 0 3.16.58 4.34 1.71l2.45-2.45C16.92 2.77 14.54 2 12 2 8.1 2 4.81 3.63 3.06 6.39l2.84 1.68c.86-2.58 3.27-4.49 6.1-4.49z" fill="#EA4335"/></svg>
                Sign In with Google
            </button>
        </div>
        
        <!-- Main Application (Hidden until authenticated) -->
        <div id="main-app" class="hidden">
            <!-- Tabs -->
            <div class="flex bg-white rounded-t-xl overflow-hidden border-b border-gray-200 shadow-sm">
                <button data-type="text" class="tab-btn flex-1 py-3 px-4 text-center font-semibold transition-colors duration-200 bg-indigo-600 text-white shadow-lg">
                    Paste Text/Code
                </button>
                <button data-type="file" class="tab-btn flex-1 py-3 px-4 text-center font-semibold transition-colors duration-200 bg-white text-gray-700 hover:bg-gray-50">
                    Upload File (Base64)
                </button>
            </div>

            <!-- Input Form -->
            <form id="content-form" class="p-6 bg-white shadow-lg rounded-b-xl space-y-4 mb-6">
                <div id="form-fields">
                    <!-- Fields dynamically loaded here -->
                </div>
                <div id="file-info" class="text-sm text-gray-500 hidden"></div>
                <button type="submit" id="save-btn" disabled
                        class="w-full py-3 rounded-lg font-semibold text-white transition-colors duration-200 shadow-md bg-gray-400 cursor-not-allowed">
                    Save Content
                </button>
                <div id="save-message" class="p-3 text-center rounded-lg text-green-700 bg-green-100 hidden"></div>
            </form>

            <!-- Saved Items List -->
            <div class="pt-4">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">Current Folder: <span id="current-folder-name" class="text-indigo-600">Root</span></h2>

                <!-- Feature: Folder Management, Breadcrumbs, and Search/Filter -->
                <div class="bg-white p-4 rounded-xl shadow-md mb-4 space-y-3">
                    <!-- Breadcrumb/Navigation -->
                    <div id="folder-breadcrumb" class="text-sm font-medium text-gray-500 border-b pb-2 mb-2">
                        <!-- Breadcrumbs rendered here -->
                    </div>

                    <!-- Actions and Search -->
                    <div class="flex flex-col sm:flex-row gap-3">
                        <input type="text" id="search-input" placeholder="Search by name..."
                            class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                        
                        <select id="filter-type" class="p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 flex-shrink-0">
                            <option value="all">All Items</option>
                            <option value="folder">Folders Only</option>
                            <option value="text">Text/Code Pastes</option>
                            <option value="file">Uploaded Files</option>
                        </select>

                        <button id="create-folder-btn" 
                                class="px-4 py-2 rounded-lg font-medium text-white bg-blue-600 hover:bg-blue-700 transition-colors flex-shrink-0">
                            + New Folder
                        </button>
                    </div>
                </div>

                <p class="text-sm text-gray-600 mb-3">
                    Showing <span id="item-count">0</span> items in current view.
                </p>

                <div id="item-list" class="grid gap-4 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-2">
                    <div id="empty-state" class="p-10 text-center bg-white rounded-xl shadow-md text-gray-500 col-span-full">
                        Loading your saved items...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Content Preview MODAL -->
    <div id="content-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 hidden flex items-center justify-center p-4" onclick="closeModal(event)">
        <!-- MODAL CONTENT: max-h-[90vh] flex-col for mobile scroll fix -->
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col" onclick="event.stopPropagation()">
            <!-- Header (Fixed) -->
            <div class="p-6 border-b border-gray-200 flex justify-between items-center flex-shrink-0">
                <h3 id="modal-title" class="text-xl font-bold text-gray-800 truncate">Content Preview</h3>
                <button onclick="closeModal()" class="text-gray-400 hover:text-gray-600 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <!-- Content Area (Scrollable) -->
            <div class="modal-content-area p-6">
                <!-- Media Preview -->
                <div id="modal-media-container" class="mb-4 flex justify-center max-h-[40vh] overflow-hidden rounded-lg border border-gray-300 p-2 bg-gray-100 hidden">
                    <!-- Media (img/video/audio) will be inserted here -->
                </div>

                <div id="modal-content-details">
                    <div class="text-xs font-semibold text-gray-700 mb-2">
                        Raw Content / Base64 String:
                    </div>
                    <pre id="modal-content-preview" class="p-3 bg-gray-100 rounded-lg text-sm font-mono whitespace-pre-wrap break-all overflow-auto max-h-[25vh]">Loading content...</pre>
                </div>

                <div id="modal-file-info" class="mt-4 text-sm text-gray-600"></div>
            </div>
            <!-- Footer (Fixed, ensures buttons are visible on mobile) -->
            <div class="p-4 border-t border-gray-200 flex justify-end gap-3 flex-wrap flex-shrink-0">
                <!-- Buttons are dynamically inserted/re-added here -->
            </div>
        </div>
    </div>

    <!-- Firebase SDK Modules (Updated to 11.6.1 stable for CDN) -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";
        
        import { 
            getAuth, 
            onAuthStateChanged, 
            GoogleAuthProvider, 
            signInWithPopup, 
            signInWithEmailAndPassword, 
            createUserWithEmailAndPassword,
            signOut
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        import { 
            getFirestore, 
            collection, 
            addDoc, 
            onSnapshot, 
            deleteDoc, 
            doc,
            getDoc, 
            query,
            getDocs,
            setDoc,
            updateDoc, // NEW: for renaming
            where,     // NEW: for folder filtering
            orderBy
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL SETUP & FIREBASE INITIALIZATION ---

        // WARNING: Replace with your actual Firebase Configuration for a production environment.
        const firebaseConfig = {
            apiKey: "AIzaSyC4dWBM-Sny6PGuPDa_oeOj7dfOBgaoB2c",
            authDomain: "datavault-e4ce1.firebaseapp.com",
            projectId: "datavault-e4ce1",
            storageBucket: "datavault-e4ce1.firebasestorage.app",
            messagingSenderId: "297745244903",
            appId: "1:297745244903:web:b0f98716741a09c528f842",
            measurementId: "G-LWN453FF1P"
        };

        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app); 
        const db = getFirestore(app);
        const auth = getAuth(app);
        setLogLevel('debug'); 

        const GITHUB_APP_ID = 'secure-data-vault-github'; 
        let userId = null;
        let currentUploadType = 'text';
        let savedItems = [];      // Holds all fetched items from Firestore
        let currentFilter = 'all'; 
        let currentSearchTerm = ''; // NEW: Search term state
        let currentFolderId = 'root'; // NEW: Folder state
        const CHUNK_SIZE = 500 * 1024; // 500 KB limit per chunk

        // --- UTILITY FUNCTIONS ---

        /** Converts a File object to its Base64 content and MIME type. */
        const fileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    const base64Content = reader.result.split(',')[1];
                    resolve({ base64Content, mimeType: file.type || 'application/octet-stream' });
                };
                reader.onerror = (error) => reject(error);
            });
        };

        /** Copies text to the clipboard and provides visual feedback. */
        const copyTextToClipboard = (text, buttonElement) => {
            const originalText = buttonElement.textContent;
            try {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = 0;
                document.body.appendChild(textarea);
                textarea.focus();
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                
                buttonElement.textContent = "Copied!";
                setTimeout(() => buttonElement.textContent = originalText, 1500);
                return true;
            } catch (err) {
                console.error('Failed to copy text:', err);
                buttonElement.textContent = "Error Copying!";
                setTimeout(() => buttonElement.textContent = originalText, 1500);
                return false;
            }
        };

        /** Displays a temporary message in a specific UI element. */
        const showMessage = (elementId, message, isError = false) => {
            const el = document.getElementById(elementId);
            el.textContent = message;
            el.classList.remove('hidden', 'bg-red-100', 'text-red-700', 'bg-green-100', 'text-green-700', 'bg-yellow-100', 'text-yellow-700');
            el.classList.add(isError ? 'bg-red-100' : 'bg-green-100', isError ? 'text-red-700' : 'text-green-700');
            if (!isError) {
                setTimeout(() => el.classList.add('hidden'), 5000);
            }
        };
        
        // Modal functions
        const openModal = () => document.getElementById('content-modal').classList.remove('hidden');
        window.closeModal = (event) => { // Made global for onclick in HTML
            if (!event || event.currentTarget.id === 'content-modal' || !event.currentTarget.id) {
                document.getElementById('content-modal').classList.add('hidden');
                // Clean up URL parameter when closing the modal, without reloading the page
                if (window.history.replaceState) {
                    const url = new URL(window.location.href);
                    // Check only for transient params, leave 'folder' intact
                    if (url.searchParams.has('fileid') || url.searchParams.has('raw') || url.searchParams.has('html')) {
                        url.searchParams.delete('fileid');
                        url.searchParams.delete('raw');
                        url.searchParams.delete('html');
                        window.history.replaceState(null, '', url.toString());
                    }
                }
            }
        };

        const getFileParamsFromUrl = () => {
            const params = new URLSearchParams(window.location.search);
            const fileId = params.get('fileid') || params.get('raw') || params.get('html'); 
            return {
                fileId: fileId,
                isRaw: params.has('raw'),
                isHtml: params.has('html')
            };
        };
        
        /** NEW: Loads current folder ID from URL and updates history if needed. */
        const loadFolderIdFromUrl = () => {
            const params = new URLSearchParams(window.location.search);
            const urlFolderId = params.get('folder');
            currentFolderId = urlFolderId || 'root';

            // Ensure the UI reflects the folder name (we assume 'root' is named 'Root')
            const folderName = currentFolderId === 'root' 
                ? 'Root' 
                : savedItems.find(item => item.id === currentFolderId)?.filename || currentFolderId;
            document.getElementById('current-folder-name').textContent = folderName;

            renderBreadcrumb();
            return currentFolderId;
        };

        /** NEW: Updates the URL to reflect a new folder. */
        const navigateToFolder = (folderId) => {
            if (window.history.pushState) {
                const url = new URL(window.location.href);
                if (folderId === 'root') {
                    url.searchParams.delete('folder');
                } else {
                    url.searchParams.set('folder', folderId);
                }
                window.history.pushState({ path: url.toString() }, '', url.toString());
                // After changing URL, reload data for the new folder
                loadFolderIdFromUrl();
                attachDataListener();
            }
        };

        /** NEW: Renders the folder breadcrumb. */
        const renderBreadcrumb = () => {
            const breadcrumbEl = document.getElementById('folder-breadcrumb');
            let path = [];
            let current = currentFolderId;

            // Simple breadcrumb: [Root] > [Current Folder Name]
            // For simplicity, we only show one level above root.
            if (current !== 'root') {
                const currentFolder = savedItems.find(item => item.id === current);
                const parentId = currentFolder ? currentFolder.folderId : 'root';
                
                path.push({ id: 'root', name: 'Root' });
                if (parentId !== 'root') {
                     path.push({ id: parentId, name: '...' }); // Placeholder for parent
                }
                if (currentFolder) {
                    path.push({ id: current, name: currentFolder.filename });
                } else {
                    path.push({ id: current, name: current });
                }
            } else {
                path.push({ id: 'root', name: 'Root' });
            }

            breadcrumbEl.innerHTML = path.map((segment, index) => {
                const isLast = index === path.length - 1;
                const linkClass = isLast 
                    ? 'text-indigo-600 font-bold' 
                    : 'text-gray-500 hover:text-gray-700 transition-colors cursor-pointer';

                return `
                    <span class="${linkClass}" onclick="${isLast ? '' : `MapsToFolder('${segment.id}')`}">
                        ${segment.name}
                    </span>
                    ${!isLast ? ' <span class="mx-1 text-gray-300">/</span> ' : ''}
                `;
            }).join('');
        };


        // --- FIRESTORE DATA CHUNKING AND ASSEMBLY LOGIC ---

        /** Gets the Firestore collection reference for the current user's files. */
        const getUserCollectionRef = () => {
            if (!userId) throw new Error("User not authenticated.");
            // All files and folders live in this collection
            return collection(db, `artifacts/${GITHUB_APP_ID}/users/${userId}/files`);
        };

        /** Saves content, splitting into chunks if necessary. */
        const saveContent = async (data) => {
            const content = data.content;
            const isLarge = content.length > CHUNK_SIZE;
            const numChunks = Math.ceil(content.length / CHUNK_SIZE);
            const folderIdToSave = loadFolderIdFromUrl(); // Get current folder ID

            const filesCollectionRef = getUserCollectionRef();
            const docRef = await addDoc(filesCollectionRef, {
                type: data.type,
                filename: data.filename,
                mimeType: data.mimeType,
                isChunked: isLarge,
                userId: userId,
                createdAt: Date.now(),
                folderId: folderIdToSave // NEW: Store folder ID
            });
            
            const chunkPromises = [];
            for (let i = 0; i < numChunks; i++) {
                const chunk = content.substring(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
                const chunkDocRef = doc(db, `artifacts/${GITHUB_APP_ID}/users/${userId}/files/${docRef.id}/chunks`, i.toString());
                
                chunkPromises.push(setDoc(chunkDocRef, { index: i, content: chunk }));
            }
            
            await Promise.all(chunkPromises);
            return docRef.id;
        };

        /** Fetches all chunks and reconstructs the full Base64 content. */
        const fetchContentAndReconstruct = async (docId) => {
            const chunksRef = collection(db, `artifacts/${GITHUB_APP_ID}/users/${userId}/files/${docId}/chunks`);
            
            // NOTE: orderBy is used here because the 'index' field is expected to be present on the client.
            const q = query(chunksRef, orderBy("index")); 
            const chunkSnapshot = await getDocs(q);

            const chunks = [];
            chunkSnapshot.forEach(chunkDoc => {
                chunks.push(chunkDoc.data());
            });

            if (chunks.length === 0) {
                 // Check if the file metadata exists before concluding an error
                 const docRef = doc(db, `artifacts/${GITHUB_APP_ID}/users/${userId}/files`, docId);
                 const docSnap = await getDoc(docRef);
                 if (docSnap.exists()) {
                     // If doc exists but no chunks, assume it's a zero-length text paste or folder
                     if (docSnap.data().type === 'text' || docSnap.data().type === 'folder') return '';
                 }
                 throw new Error("Content chunks not found or inaccessible.");
            }

            const fullContent = chunks
                .sort((a, b) => a.index - b.index) // Ensure correct order client-side, just in case
                .map(c => c.content)
                .join('');
                
            return fullContent;
        };
        
        /** Recursively checks if a folder is empty (only checks its immediate children). */
        const isFolderEmpty = async (folderId) => {
            const filesCollectionRef = getUserCollectionRef();
            // Look for any item (file or folder) whose parent is this folder
            const q = query(filesCollectionRef, where("folderId", "==", folderId));
            const snapshot = await getDocs(q);
            return snapshot.empty;
        };

        /** Shows a confirmation modal and deletes the item and all its chunks on confirmation. */
        const deleteContent = async (docId, filename, type) => {
            if (type === 'folder') {
                const isEmpty = await isFolderEmpty(docId);
                if (!isEmpty) {
                    showMessage('save-message', `Folder '${filename}' is not empty. Please delete all contents first.`, true);
                    return;
                }
            }

            // Using custom modal instead of window.confirm (implementation omitted for brevity, using simple confirm)
            // Reusing the modal for confirmation as a temporary solution
            const confirmDelete = await new Promise(resolve => {
                const modal = document.getElementById('content-modal');
                const title = document.getElementById('modal-title');
                const content = document.getElementById('modal-content-preview');
                const footer = modal.querySelector('.p-4.border-t');

                title.textContent = `Confirm Deletion`;
                content.textContent = `Are you sure you want to delete the ${type} '${filename}'? This action cannot be undone.`;
                document.getElementById('modal-file-info').textContent = '';
                document.getElementById('modal-media-container').classList.add('hidden');
                
                footer.innerHTML = `
                    <button id="cancel-delete-btn" class="px-4 py-2 text-sm font-medium rounded-lg text-gray-600 border border-gray-300 hover:bg-gray-100 transition-colors">
                        Cancel
                    </button>
                    <button id="confirm-delete-btn" class="px-4 py-2 text-sm font-medium rounded-lg text-white bg-red-600 hover:bg-red-700 transition-colors">
                        Delete Permanently
                    </button>
                `;

                document.getElementById('cancel-delete-btn').onclick = () => { closeModal(); resolve(false); };
                document.getElementById('confirm-delete-btn').onclick = () => { closeModal(); resolve(true); };
                openModal();
            });

            if (!confirmDelete) return;

            try {
                // Only delete chunks if it's not a folder (folders have no chunks)
                if (type !== 'folder') {
                    const chunksRef = collection(db, `artifacts/${GITHUB_APP_ID}/users/${userId}/files/${docId}/chunks`);
                    const chunkSnapshot = await getDocs(chunksRef);
                    const deleteChunkPromises = [];
                    chunkSnapshot.forEach(chunkDoc => {
                        deleteChunkPromises.push(deleteDoc(doc(db, chunksRef.path, chunkDoc.id)));
                    });
                    await Promise.all(deleteChunkPromises);
                }

                // Delete Parent Document
                const docRef = doc(db, `artifacts/${GITHUB_APP_ID}/users/${userId}/files`, docId);
                await deleteDoc(docRef);
                showMessage('save-message', `${type === 'folder' ? 'Folder' : 'Item'} '${filename}' deleted successfully!`);
            } catch (error) {
                console.error("Error deleting document:", error);
                showMessage('save-message', `Error deleting item: ${error.message}`, true);
            }
        };
        
        /** NEW: Handles renaming a file or folder. */
        const renameContent = async (docId, currentName, type) => {
             // Custom prompt for input instead of window.prompt
            const newName = await new Promise(resolve => {
                const modal = document.getElementById('content-modal');
                const title = document.getElementById('modal-title');
                const content = document.getElementById('modal-content-preview');
                const footer = modal.querySelector('.p-4.border-t');

                title.textContent = `Rename ${type}`;
                content.innerHTML = `
                    <p class="mb-2">Enter a new name for '${currentName}':</p>
                    <input id="rename-input" type="text" value="${currentName}" 
                           class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                `;
                document.getElementById('modal-file-info').textContent = '';
                document.getElementById('modal-media-container').classList.add('hidden');
                
                footer.innerHTML = `
                    <button id="cancel-rename-btn" class="px-4 py-2 text-sm font-medium rounded-lg text-gray-600 border border-gray-300 hover:bg-gray-100 transition-colors">
                        Cancel
                    </button>
                    <button id="confirm-rename-btn" class="px-4 py-2 text-sm font-medium rounded-lg text-white bg-indigo-600 hover:bg-indigo-700 transition-colors">
                        Rename
                    </button>
                `;
                openModal();

                document.getElementById('cancel-rename-btn').onclick = () => { closeModal(); resolve(null); };
                document.getElementById('confirm-rename-btn').onclick = () => { 
                    const input = document.getElementById('rename-input').value.trim();
                    closeModal(); 
                    resolve(input); 
                };
            });

            if (!newName || newName === currentName) return;

            try {
                const docRef = doc(db, `artifacts/${GITHUB_APP_ID}/users/${userId}/files`, docId);
                await updateDoc(docRef, { filename: newName });
                showMessage('save-message', `${type} renamed to '${newName}' successfully!`);
            } catch (error) {
                console.error("Error renaming document:", error);
                showMessage('save-message', `Error renaming: ${error.message}`, true);
            }
        }


        // --- RAW & HTML CONTENT RENDERING (for URL modes) ---

        /** Renders the content directly to the body for raw viewing. */
        const renderRawContent = async (fileId) => {
            // ... (Raw Content logic remains the same)
            document.body.innerHTML = 'Loading RAW Content...';
            document.body.classList.add('raw-mode');
            
            try {
                const docRef = doc(db, `artifacts/${GITHUB_APP_ID}/users/${userId}/files`, fileId);
                const docSnap = await getDoc(docRef);
                if (!docSnap.exists() || docSnap.data().type === 'folder') { // Don't show raw folder content
                    throw new Error(`File ID "${fileId}" not found, inaccessible, or is a folder.`);
                }
                const { filename, mimeType, type } = docSnap.data();

                const fullContent = await fetchContentAndReconstruct(fileId);
                const isText = type === 'text' || mimeType.includes('text/plain') || mimeType.includes('text/html') || mimeType.includes('application/json');
                let contentToDisplay;

                if (isText) {
                    try {
                        contentToDisplay = atob(fullContent); 
                    } catch (e) {
                        contentToDisplay = fullContent;
                    }
                } else {
                    contentToDisplay = fullContent;
                }

                document.title = `RAW: ${filename}`;
                document.body.textContent = contentToDisplay;

            } catch (error) {
                document.title = 'Error Loading RAW';
                document.body.textContent = `ERROR: Failed to load content: ${error.message}. Please sign in with the correct account or check the file ID.`;
                document.body.style.color = '#ff6b6b'; 
                console.error('RAW Content Error:', error);
            }
        };

        /** Renders the content directly to the body for executable HTML viewing. */
        const renderHtmlContent = async (fileId) => {
            // ... (HTML Content logic remains the same)
             document.documentElement.innerHTML = '<body>Loading HTML Preview...</body>';
            document.title = 'Loading Preview...';
            
            try {
                const docRef = doc(db, `artifacts/${GITHUB_APP_ID}/users/${userId}/files`, fileId);
                const docSnap = await getDoc(docRef);
                if (!docSnap.exists() || docSnap.data().type === 'folder') {
                    throw new Error(`File ID "${fileId}" not found, inaccessible, or is a folder.`);
                }
                const { filename, mimeType, type } = docSnap.data();

                if (mimeType !== 'text/html' && type !== 'text') {
                     throw new Error(`File type ${mimeType} cannot be safely rendered as executable HTML.`);
                }

                const fullBase64Content = await fetchContentAndReconstruct(fileId);
                let contentToDisplay;
                try {
                    contentToDisplay = atob(fullBase64Content); 
                } catch (e) {
                    contentToDisplay = fullBase64Content;
                }
                
                document.title = `PREVIEW: ${filename}`;
                
                document.open();
                document.write(contentToDisplay);
                document.close();
                
            } catch (error) {
                document.title = 'Error Loading HTML';
                document.documentElement.innerHTML = `
                    <body class="bg-gray-900 text-red-400 p-8 font-sans">
                        <h1 class="text-2xl font-bold mb-4">Error Loading HTML Content</h1>
                        <p>Failed to load and render content: ${error.message}.</p>
                        <p class="text-sm mt-4">Please sign in with the correct account or check the file ID.</p>
                        <a href="/" class="text-blue-400 hover:text-blue-200 mt-2 block">Go Back to Data Vault</a>
                    </body>`;
                console.error('HTML Preview Error:', error);
            }
        };


        // --- CONTENT LOADING AND MODAL RENDERING ---

        /** Loads content, reconstructs it, and populates the preview modal. */
        const loadContentAndOpenModal = async (docId, filename, mimeType, itemType, elementToUpdate = null) => {
            if (itemType === 'folder') {
                 // Folders don't have content to preview in the modal, they navigate
                 navigateToFolder(docId);
                 return;
            }
            
            // UI state while loading
            const isTextType = mimeType.includes('text/') || mimeType.includes('application/json');
            const canViewHtml = itemType === 'text' || mimeType.includes('text/html'); 
            
            if (elementToUpdate) {
                elementToUpdate.textContent = 'Loading...';
                elementToUpdate.disabled = true;
                elementToUpdate.classList.remove('hover:bg-indigo-100');
            }

            const modalTitle = document.getElementById('modal-title');
            const modalPreview = document.getElementById('modal-content-preview');
            const modalInfo = document.getElementById('modal-file-info');
            const mediaContainer = document.getElementById('modal-media-container');

            modalTitle.textContent = filename;
            modalPreview.textContent = 'Fetching and reassembling content chunks...';
            modalInfo.textContent = '';
            mediaContainer.innerHTML = '';
            mediaContainer.classList.add('hidden');

            // Reset modal footer to original state
            const shareLink = `${window.location.origin}${window.location.pathname}?fileid=${docId}`;
            const rawLink = `${window.location.origin}${window.location.pathname}?raw=${docId}`;
            const htmlLink = `${window.location.origin}${window.location.pathname}?html=${docId}`;

            const footer = document.getElementById('content-modal').querySelector('.p-4.border-t');
            footer.innerHTML = `
                ${canViewHtml ? `
                    <a id="modal-view-html-btn" href="${htmlLink}" target="_blank" class="px-4 py-2 text-sm font-medium rounded-lg text-fuchsia-600 border border-fuchsia-600 bg-fuchsia-50 hover:bg-fuchsia-100 transition-colors" title="Opens the content in a new window, rendered as functional HTML.">
                        View Executable HTML
                    </a>
                ` : ''}
                <a id="modal-download-btn" href="#" download class="px-4 py-2 text-sm font-medium rounded-lg text-teal-600 border border-teal-600 bg-teal-50 hover:bg-teal-100 transition-colors">
                    Download File
                </a>
                 <button id="modal-rename-btn" class="px-4 py-2 text-sm font-medium rounded-lg text-yellow-600 border border-yellow-600 bg-yellow-50 hover:bg-yellow-100 transition-colors">
                    Rename
                </button>
                <button id="modal-share-btn" class="px-4 py-2 text-sm font-medium rounded-lg text-indigo-600 border border-indigo-600 hover:bg-indigo-50 transition-colors">
                    Copy Share Link
                </button>
                <a id="modal-raw-link-btn" href="${rawLink}" target="_blank" class="px-4 py-2 text-sm font-medium rounded-lg text-gray-700 border border-gray-300 hover:bg-gray-100 transition-colors">
                    Open Raw Content
                </a>
                <button id="modal-copy-btn" class="px-4 py-2 text-sm font-medium rounded-lg text-white bg-indigo-600 hover:bg-indigo-700 transition-colors">
                    Copy Raw Content
                </button>
            `;
            // Re-fetch button elements after resetting the innerHTML
            const modalDownloadBtnFinal = document.getElementById('modal-download-btn');
            const modalCopyBtnFinal = document.getElementById('modal-copy-btn');
            const modalShareBtnFinal = document.getElementById('modal-share-btn');
            const modalRenameBtnFinal = document.getElementById('modal-rename-btn');
            
            // Set up rename button for modal
            modalRenameBtnFinal.onclick = () => {
                closeModal(); // Close current modal before opening rename modal
                renameContent(docId, filename, itemType);
            };

            try {
                const fullContent = await fetchContentAndReconstruct(docId);
                const dataUri = `data:${mimeType};base64,${fullContent}`;
                
                let contentToDisplay;
                if (isTextType) {
                    try {
                        contentToDisplay = atob(fullContent);
                    } catch (e) {
                        contentToDisplay = fullContent; // Fallback to raw base64 if decoding fails
                    }
                } else {
                    contentToDisplay = fullContent;
                }

                // --- Media Rendering (Image/Video/Audio) ---
                if (mimeType.startsWith('image/') || mimeType.startsWith('video/') || mimeType.startsWith('audio/')) {
                    mediaContainer.classList.remove('hidden');
                    let mediaElement;
                    
                    if (mimeType.startsWith('image/')) {
                        mediaElement = document.createElement('img');
                        mediaElement.alt = filename;
                    } else if (mimeType.startsWith('video/') || mimeType.startsWith('audio/')) {
                        mediaElement = document.createElement(mimeType.startsWith('video/') ? 'video' : 'audio');
                        mediaElement.controls = true;
                        mediaElement.autoplay = false;
                        mediaElement.loop = false;
                    }

                    if (mediaElement) {
                        mediaElement.src = dataUri;
                        mediaContainer.appendChild(mediaElement);
                    }
                }

                // 2. Populate Modal (Raw Content View)
                modalPreview.textContent = contentToDisplay;
                
                // 3. Populate Info
                modalInfo.innerHTML = `
                    Type: <strong>${mimeType}</strong> | 
                    Base64 Length: <strong>${(fullContent.length / 1024).toFixed(2)} KB</strong> 
                    ${fullContent.length > CHUNK_SIZE ? '<span class="text-orange-600 font-semibold">(Stored in Chunks)</span>' : ''}
                `;

                // 4. Set up Download Link
                modalDownloadBtnFinal.href = dataUri;
                modalDownloadBtnFinal.download = filename;

                // 5. Set up copy handlers
                modalCopyBtnFinal.textContent = isTextType ? 'Copy Text/Code' : 'Copy Base64';
                modalCopyBtnFinal.onclick = () => {
                    copyTextToClipboard(contentToDisplay, modalCopyBtnFinal);
                };

                // 6. Set up Share link copy
                modalShareBtnFinal.onclick = () => {
                    copyTextToClipboard(shareLink, modalShareBtnFinal);
                };

                openModal();

            } catch (error) {
                console.error("Error loading content:", error);
                modalPreview.textContent = `ERROR: Failed to load content. ${error.message}. Ensure the file ID is correct and you are signed in to the correct account.`;
                modalInfo.textContent = '';
                mediaContainer.classList.add('hidden');
            } finally {
                if (elementToUpdate) {
                    elementToUpdate.textContent = 'View / Copy';
                    elementToUpdate.disabled = false;
                    elementToUpdate.classList.add('hover:bg-indigo-100');
                }
            }
        };

        // --- UI RENDERING FUNCTIONS ---

        const handleTabClick = (e) => {
            currentUploadType = e.currentTarget.dataset.type;
            document.querySelectorAll('.tab-btn').forEach(btn => {
                if (btn.dataset.type === currentUploadType) {
                    btn.classList.add('bg-indigo-600', 'text-white', 'shadow-lg');
                    btn.classList.remove('bg-white', 'text-gray-700', 'hover:bg-gray-50');
                } else {
                    btn.classList.remove('bg-indigo-600', 'text-white', 'shadow-lg');
                    btn.classList.add('bg-white', 'text-gray-700', 'hover:bg-gray-50');
                }
            });
            renderFormFields();
        };

        const handleFormSubmit = async (e) => {
            e.preventDefault();
            document.getElementById('save-message').classList.add('hidden');
            const saveBtn = document.getElementById('save-btn');
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;

            try {
                let data = {};

                if (currentUploadType === 'text') {
                    const textContent = document.getElementById('paste-text').value.trim();
                    if (!textContent) throw new Error("Text content cannot be empty.");
                    
                    const base64Content = btoa(textContent);

                    data = {
                        type: 'text',
                        filename: document.getElementById('paste-title').value.trim() || `Paste-${new Date().toLocaleTimeString()}`,
                        mimeType: 'text/plain',
                        content: base64Content
                    };
                    document.getElementById('paste-text').value = ''; // Clear form
                    document.getElementById('paste-title').value = '';
                } else { // 'file'
                    const fileInput = document.getElementById('file-upload');
                    const file = fileInput.files[0];
                    if (!file) throw new Error("Please select a file to upload.");
                    
                    const { base64Content, mimeType } = await fileToBase64(file);

                    data = {
                        type: 'file',
                        filename: file.name,
                        mimeType: mimeType,
                        content: base64Content
                    };
                    fileInput.value = ''; // Clear form
                }

                await saveContent(data);
                showMessage('save-message', `${data.type === 'file' ? 'File' : 'Text'} saved successfully!`);

            } catch (error) {
                console.error("Save Error:", error);
                showMessage('save-message', `Failed to save: ${error.message}`, true);
            } finally {
                saveBtn.textContent = originalText;
                toggleSaveButton();
            }
        };

        const handleCreateFolder = async () => {
            // Using modal for input instead of window.prompt
            const folderName = await new Promise(resolve => {
                const modal = document.getElementById('content-modal');
                const title = document.getElementById('modal-title');
                const content = document.getElementById('modal-content-preview');
                const footer = modal.querySelector('.p-4.border-t');

                title.textContent = 'Create New Folder';
                content.innerHTML = `
                    <p class="mb-2">Enter the name for your new folder:</p>
                    <input id="folder-name-input" type="text" placeholder="e.g., 'Projects' or 'Shared Docs'"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                `;
                document.getElementById('modal-file-info').textContent = '';
                document.getElementById('modal-media-container').classList.add('hidden');
                
                footer.innerHTML = `
                    <button id="cancel-folder-btn" class="px-4 py-2 text-sm font-medium rounded-lg text-gray-600 border border-gray-300 hover:bg-gray-100 transition-colors">
                        Cancel
                    </button>
                    <button id="confirm-folder-btn" class="px-4 py-2 text-sm font-medium rounded-lg text-white bg-indigo-600 hover:bg-indigo-700 transition-colors">
                        Create Folder
                    </button>
                `;
                openModal();
                document.getElementById('folder-name-input').focus();

                document.getElementById('cancel-folder-btn').onclick = () => { closeModal(); resolve(null); };
                document.getElementById('confirm-folder-btn').onclick = () => { 
                    const input = document.getElementById('folder-name-input').value.trim();
                    closeModal(); 
                    resolve(input); 
                };
            });
            
            if (!folderName) return;

            try {
                const filesCollectionRef = getUserCollectionRef();
                await addDoc(filesCollectionRef, {
                    type: 'folder',
                    filename: folderName,
                    mimeType: 'folder/directory',
                    isChunked: false,
                    userId: userId,
                    createdAt: Date.now(),
                    folderId: currentFolderId
                });
                showMessage('save-message', `Folder '${folderName}' created successfully!`);
            } catch (error) {
                console.error("Create Folder Error:", error);
                showMessage('save-message', `Failed to create folder: ${error.message}`, true);
            }
        };

        const toggleSaveButton = () => {
            const saveBtn = document.getElementById('save-btn');
            const isTextTab = currentUploadType === 'text';
            
            let shouldBeDisabled = true;
            
            if (isTextTab) {
                const textInput = document.getElementById('paste-text');
                if (textInput && textInput.value.trim().length > 0) {
                    shouldBeDisabled = false;
                }
            } else { 
                shouldBeDisabled = false; 
            }

            saveBtn.disabled = shouldBeDisabled;
            if (shouldBeDisabled) {
                saveBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
                saveBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
            } else {
                saveBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
                saveBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            }
        };

        /** Renders a single item card for the list. */
        const renderItemCard = (item) => {
            const formattedDate = new Date(item.createdAt).toLocaleString();
            
            // Item Type Styling and Labels
            const isFolder = item.type === 'folder';
            const typeLabel = isFolder ? 'Folder' : (item.type === 'text' ? 'Paste' : 'File');
            const typeColor = isFolder ? 'bg-blue-100 text-blue-700' : (item.type === 'text' ? 'bg-green-100 text-green-700' : 'bg-purple-100 text-purple-700');
            const cardClass = isFolder ? 'folder-card' : '';
            
            // Links
            const standardLink = `${window.location.origin}${window.location.pathname}?fileid=${item.id}`;
            const rawLink = `${window.location.origin}${window.location.pathname}?raw=${item.id}`; 
            const htmlLink = `${window.location.origin}${window.location.pathname}?html=${item.id}`; 
            const isHtmlOrText = item.type === 'text' || item.mimeType.includes('text/html');

            const card = document.createElement('div');
            card.className = `bg-white p-4 border border-gray-200 rounded-xl shadow-sm hover:shadow-md transition-shadow flex flex-col justify-between ${cardClass}`;
            card.innerHTML = `
                <div>
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="text-lg font-semibold text-gray-900 break-words max-w-[80%] flex items-center">
                            ${isFolder ? `<svg class="w-5 h-5 mr-2 text-blue-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"></path></svg>` : ''}
                            ${item.filename}
                        </h3>
                        <span class="text-xs font-medium px-2 py-1 rounded-full whitespace-nowrap ${typeColor}">
                            ${typeLabel}
                        </span>
                    </div>
                    <p class="text-xs text-gray-500 mb-3">
                        Saved: ${formattedDate}
                    </p>
                    <div class="text-xs text-gray-400 mb-2 flex justify-between items-center">
                        <span>${isFolder ? 'Folder ID' : (item.isChunked ? '<span class="text-orange-600 font-semibold">LARGE (Chunked)</span>' : 'Small Content')}</span>
                        <button class="copy-id-btn text-xs text-indigo-400 hover:text-indigo-600 transition-colors"
                            data-id="${item.id}">
                            Copy ID
                        </button>
                    </div>
                </div>

                <!-- Action Bar -->
                <div class="flex flex-wrap gap-2 pt-2 border-t border-gray-100">
                    ${isFolder ? `
                        <button class="load-folder-btn flex-1 min-w-[100px] text-center px-3 py-1.5 text-sm font-medium rounded-lg text-indigo-600 bg-indigo-50 hover:bg-indigo-100 transition-colors"
                            data-id="${item.id}">
                            Open Folder
                        </button>
                    ` : `
                        <button class="load-content-btn flex-1 min-w-[100px] text-center px-3 py-1.5 text-sm font-medium rounded-lg text-indigo-600 bg-indigo-50 hover:bg-indigo-100 transition-colors"
                            data-id="${item.id}" 
                            data-filename="${item.filename}"
                            data-mimetype="${item.mimeType}"
                            data-type="${item.type}">
                            View / Copy
                        </button>
                    `}
                    ${!isFolder && isHtmlOrText ? `
                        <a href="${htmlLink}" target="_blank" class="flex-1 min-w-[100px] text-center px-3 py-1.5 text-sm font-medium rounded-lg text-fuchsia-600 bg-fuchsia-100 hover:bg-fuchsia-200 transition-colors" title="Open and execute as functional HTML">
                            View HTML
                        </a>
                    ` : ''}
                    <button class="rename-btn w-full sm:w-auto px-3 py-1.5 text-sm font-medium rounded-lg text-yellow-600 bg-yellow-50 hover:bg-yellow-100 transition-colors"
                        data-id="${item.id}" 
                        data-filename="${item.filename}"
                        data-type="${typeLabel}">
                        Rename
                    </button>
                    <button class="delete-btn w-full sm:w-auto px-3 py-1.5 text-sm font-medium rounded-lg text-red-600 bg-red-50 hover:bg-red-100 transition-colors"
                        data-id="${item.id}" 
                        data-filename="${item.filename}"
                        data-type="${item.type}">
                        Delete
                    </button>
                </div>
            `;

            // Attach event listeners after rendering the static part

            // Folder Navigation
            if (isFolder) {
                card.querySelector('.load-folder-btn').addEventListener('click', (e) => {
                    navigateToFolder(e.target.dataset.id);
                });
            } else {
                const loadBtn = card.querySelector('.load-content-btn');
                loadBtn.addEventListener('click', async () => {
                    loadContentAndOpenModal(item.id, item.filename, item.mimeType, item.type, loadBtn);
                });
            }

            // Delete Handler
            card.querySelector('.delete-btn').addEventListener('click', (e) => {
                deleteContent(item.id, e.target.dataset.filename, e.target.dataset.type);
            });
            
            // Rename Handler
            card.querySelector('.rename-btn').addEventListener('click', (e) => {
                renameContent(e.target.dataset.id, e.target.dataset.filename, e.target.dataset.type);
            });

            // Copy ID Handler
            card.querySelector('.copy-id-btn').addEventListener('click', (e) => {
                const id = e.target.dataset.id;
                copyTextToClipboard(id, e.target);
            });

            return card;
        };

        /** Renders the full list of items based on current folder, filter, and search. */
        const renderItemList = (items) => {
            const listContainer = document.getElementById('item-list');
            const emptyState = document.getElementById('empty-state');
            
            const filteredItems = items
                .filter(item => {
                    // Filter by Type
                    if (currentFilter !== 'all' && item.type !== currentFilter) return false;
                    
                    // Filter by Search Term (case-insensitive on filename)
                    if (currentSearchTerm && !item.filename.toLowerCase().includes(currentSearchTerm.toLowerCase())) return false;

                    return true;
                });

            // Put folders first in the list
            filteredItems.sort((a, b) => {
                if (a.type === 'folder' && b.type !== 'folder') return -1;
                if (a.type !== 'folder' && b.type === 'folder') return 1;
                // Otherwise sort by creation date (descending)
                return b.createdAt - a.createdAt; 
            });


            document.getElementById('item-count').textContent = filteredItems.length;

            listContainer.innerHTML = '';
            if (filteredItems.length === 0) {
                const message = items.length === 0 
                    ? "This folder is empty. Use the form above to store your first paste or file, or create a new folder!"
                    : "No items match the current filter/search selection.";
                emptyState.textContent = message;
                listContainer.appendChild(emptyState);
            } else {
                filteredItems.forEach(item => {
                    listContainer.appendChild(renderItemCard(item));
                });
            }
        };

        const attachFormListeners = () => {
            const textInput = document.getElementById('paste-text');
            if (textInput) {
                textInput.addEventListener('input', toggleSaveButton);
            }
            toggleSaveButton();
        };

        const renderFormFields = () => {
            const fieldsContainer = document.getElementById('form-fields');
            const fileInfo = document.getElementById('file-info');

            if (currentUploadType === 'text') {
                fieldsContainer.innerHTML = `
                    <input type="text" id="paste-title" placeholder="Title (optional, e.g., 'React Hook Logic' or 'My Webpage')" 
                        class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                    <textarea id="paste-text" placeholder="Paste your text or code here (e.g., HTML, CSS, JS, JSON)..." rows="8" required
                        class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 font-mono text-sm"></textarea>
                `;
                fileInfo.classList.add('hidden');
            } else { // 'file'
                fieldsContainer.innerHTML = `
                    <input type="file" id="file-upload" required
                        class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
                `;
                fileInfo.classList.remove('hidden');
            }
            attachFormListeners();
        };

        // --- AUTHENTICATION FLOWS ---

        /** Checks the URL for a file ID and loads it if present. */
        const loadFromUrlIfPresent = async () => {
            const { fileId, isRaw, isHtml } = getFileParamsFromUrl();
            loadFolderIdFromUrl(); // Always load folder from URL

            if (!userId) {
                if (fileId) {
                    return; 
                }
                return;
            }

            if (fileId) {
                if (isRaw) {
                    document.getElementById('app').classList.add('hidden');
                    document.body.classList.remove('bg-gray-50');
                    document.body.classList.add('bg-black');
                    document.getElementById('main-header').classList.add('hidden');
                    document.getElementById('auth-container').classList.add('hidden');
                    renderRawContent(fileId);
                    return; 
                } 
                
                if (isHtml) {
                    document.getElementById('app').classList.add('hidden');
                    document.body.classList.remove('bg-gray-50');
                    document.getElementById('main-header').classList.add('hidden');
                    document.getElementById('auth-container').classList.add('hidden');
                    renderHtmlContent(fileId);
                    return; 
                }
                
                // standard ?fileid loading
                try {
                    const docRef = doc(db, `artifacts/${GITHUB_APP_ID}/users/${userId}/files`, fileId);
                    const docSnap = await getDoc(docRef);

                    if (docSnap.exists()) {
                        const item = { id: docSnap.id, ...docSnap.data() };
                        loadContentAndOpenModal(item.id, item.filename, item.mimeType, item.type);
                    } else {
                        showMessage('auth-message', `File ID "${fileId}" not found or inaccessible.`, true);
                    }
                } catch (error) {
                    console.error("Error loading file from URL:", error);
                    showMessage('auth-message', `Error fetching file: ${error.message}`, true);
                }
            }
        }

        /** Handles the Firebase authentication state change. */
        const handleAuthStateChanged = (user) => {
            const authContainer = document.getElementById('auth-container');
            const mainApp = document.getElementById('main-app');
            const authStatus = document.getElementById('auth-status');
            const { isRaw, isHtml } = getFileParamsFromUrl(); 

            if (user) {
                userId = user.uid;
                authStatus.innerHTML = `
                    <span class="font-medium">Signed In as:</span> 
                    <code class="text-xs ml-1 px-2 py-0.5 bg-indigo-100 text-indigo-800 rounded">
                        ${user.email || user.displayName || 'Google User'}
                    </code>
                    <button id="signout-btn" class="ml-3 text-red-500 hover:text-red-700 text-sm font-medium">Sign Out</button>
                `;
                document.getElementById('signout-btn').addEventListener('click', handleSignOut);
                
                if (!isRaw && !isHtml) {
                    authContainer.classList.add('hidden');
                    mainApp.classList.remove('hidden');
                    attachDataListener();
                }

                loadFromUrlIfPresent(); 

            } else {
                userId = null;
                authStatus.textContent = 'Please sign in to access your vault.';
                
                if (!isRaw && !isHtml) {
                    authContainer.classList.remove('hidden');
                    mainApp.classList.add('hidden');
                }
                savedItems = []; 
                renderItemList([]); 
                loadFromUrlIfPresent(); 
            }
        };

        /** Sign in with Google Popup. */
        const handleGoogleSignIn = async () => {
            document.getElementById('auth-message').classList.add('hidden');
            try {
                const provider = new GoogleAuthProvider();
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Google Sign-in Error:", error);
                if (error.code !== 'auth/popup-closed-by-user') {
                    showMessage('auth-message', error.message, true);
                }
            }
        };

        /** Handles email/password sign-in or sign-up. */
        const handleEmailAuth = async (isSignUp) => {
            document.getElementById('auth-message').classList.add('hidden');
            const email = document.getElementById('auth-email').value;
            const password = document.getElementById('auth-password').value;
            if (!email || !password) return showMessage('auth-message', "Email and password are required.", true);

            try {
                if (isSignUp) {
                    await createUserWithEmailAndPassword(auth, email, password);
                    showMessage('auth-message', `Account created successfully for ${email}. Signed in.`, false);
                } else {
                    await signInWithEmailAndPassword(auth, email, password);
                    showMessage('auth-message', `Signed in as ${email}.`, false);
                }
            } catch (error) {
                console.error("Email Auth Error:", error);
                let message = error.message;
                if (error.code === 'auth/email-already-in-use') message = 'This email is already registered. Try signing in.';
                if (error.code === 'auth/invalid-credential' || error.code === 'auth/wrong-password' || error.code === 'auth/user-not-found') {
                    message = 'Invalid email or password.';
                } else if (error.code === 'auth/weak-password') {
                    message = 'Password should be at least 6 characters.';
                }
                showMessage('auth-message', message, true);
            }
        };
        
        /** Signs the user out. */
        const handleSignOut = async () => {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Sign Out Error:", error);
            }
        }

        // --- MAIN DATA LISTENER ---
        let unsubscribeData = null;

        /** Attaches the Firestore real-time listener to the user's files. */
        const attachDataListener = () => {
            if (unsubscribeData) {
                unsubscribeData();
                unsubscribeData = null;
            }

            try {
                const filesCollectionRef = getUserCollectionRef();
                const folderIdToQuery = loadFolderIdFromUrl();
                
                // Query items where folderId matches the current folderId
                // We use orderBy("type", "asc") to ensure folders (type:'folder') appear first.
                const q = query(filesCollectionRef, 
                    where("folderId", "==", folderIdToQuery),
                    orderBy("type", "asc"), 
                    orderBy("createdAt", "desc")
                );

                unsubscribeData = onSnapshot(q, (snapshot) => {
                    const fetchedItems = [];
                    snapshot.forEach((doc) => {
                        fetchedItems.push({ id: doc.id, ...doc.data() });
                    });
                    
                    savedItems = fetchedItems;
                    renderItemList(savedItems);
                }, (error) => {
                    console.error("Error listening to Firestore snapshot:", error);
                    document.getElementById('empty-state').textContent = `Error loading data: ${error.message}`;
                });
            } catch (error) {
                console.error("Failed to attach data listener:", error);
            }
        };

        // --- INITIALIZATION ---
        
        window.onload = () => {
            const { isRaw, isHtml } = getFileParamsFromUrl();
            
            if (isRaw || isHtml) {
                document.getElementById('app')?.classList.add('hidden');
                document.body.classList.remove('bg-gray-50');
                document.body.classList.add('bg-black');
            } else {
                renderFormFields();
                
                // Tab and Form Listeners
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', handleTabClick);
                });
                document.getElementById('content-form').addEventListener('submit', handleFormSubmit);

                // New Folder and Search/Filter Listeners
                document.getElementById('create-folder-btn').addEventListener('click', handleCreateFolder);

                document.getElementById('filter-type').addEventListener('change', (e) => {
                    currentFilter = e.target.value;
                    renderItemList(savedItems);
                });
                
                document.getElementById('search-input').addEventListener('input', (e) => {
                    currentSearchTerm = e.target.value.trim();
                    renderItemList(savedItems);
                });

                document.addEventListener('change', (e) => {
                    if (e.target.id === 'file-upload' && e.target.files.length > 0) {
                        const file = e.target.files[0];
                        const infoEl = document.getElementById('file-info');
                        const sizeInKB = (file.size / 1024).toFixed(2);
                        const sizeColor = file.size > CHUNK_SIZE * 0.9 ? 'text-orange-500 font-bold' : 'text-gray-500';
                        infoEl.innerHTML = `Selected: <strong>${file.name}</strong> (${sizeInKB} KB). <span class="${sizeColor}">Storage limit per chunk is ${Math.round(CHUNK_SIZE / 1024)} KB.</span>`;
                    }
                });
                
                // Handle back/forward navigation affecting the folder URL
                window.addEventListener('popstate', () => {
                    loadFolderIdFromUrl();
                    attachDataListener();
                });
            }

            // Attach Auth listeners
            document.getElementById('google-signin-btn')?.addEventListener('click', handleGoogleSignIn);
            document.getElementById('signin-btn')?.addEventListener('click', (e) => { e.preventDefault(); handleEmailAuth(false); });
            document.getElementById('signup-btn')?.addEventListener('click', (e) => { e.preventDefault(); handleEmailAuth(true); });
            
            // Start authentication listener which manages UI visibility and data loading
            onAuthStateChanged(auth, handleAuthStateChanged);
        };
    </script>
</body>
</html>

